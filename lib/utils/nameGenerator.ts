/**
 * @fileoverview Friendly name generation and avatar styling utilities
 * @module utils/nameGenerator
 *
 * This module provides deterministic name generation and avatar styling for
 * anonymous users and visitors. It ensures consistent visual identity across
 * sessions using seed-based generation.
 *
 * Features:
 * - Deterministic name generation from seeds (user IDs, session IDs)
 * - Gradient avatar generation with consistent colors
 * - Initial extraction from names
 * - Anonymous customer creation
 *
 * @example
 * ```typescript
 * import { generateDeterministicName, getAvatarGradientStyle } from '@/lib/utils/nameGenerator';
 *
 * // Generate consistent name for a user
 * const name = generateDeterministicName(userId); // "Friendly River"
 *
 * // Get matching avatar gradient
 * const style = getAvatarGradientStyle(name);
 * // Returns: { background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' }
 * ```
 */

import { adjectives, colors, animals } from 'unique-names-generator';

const legacyAdjectives = [
  "Friendly",
  "Happy",
  "Bright",
  "Clever",
  "Swift",
  "Gentle",
  "Kind",
  "Wise",
  "Bold",
  "Calm",
  "Cheerful",
  "Curious",
  "Eager",
  "Graceful",
  "Helpful",
  "Joyful",
  "Lively",
  "Peaceful",
  "Quick",
  "Radiant",
];

const legacyNames = [
  "Alex",
  "Blake",
  "Casey",
  "Drew",
  "Emery",
  "Finley",
  "Gray",
  "Harper",
  "Indigo",
  "Jordan",
  "Kai",
  "Lane",
  "Morgan",
  "Nova",
  "Ocean",
  "Parker",
  "Quinn",
  "River",
  "Sage",
  "Taylor",
];

const gradientColors = [
  ["#667eea", "#764ba2"], // Purple-Blue
  ["#f093fb", "#f5576c"], // Pink-Red
  ["#4facfe", "#00f2fe"], // Blue-Cyan
  ["#43e97b", "#38f9d7"], // Green-Teal
  ["#fa709a", "#fee140"], // Pink-Yellow
];

/**
 * Generates a random friendly 2-word name (adjective + name)
 *
 * @deprecated Use {@link generateDeterministicName} instead for consistent results
 * @returns {string} A randomly generated friendly name
 *
 * @example
 * generateFriendlyName() // "Happy Blake" (random each time)
 */
export function generateFriendlyName(): string {
  // Use current timestamp as seed for backwards compatibility
  return generateDeterministicName(Date.now().toString());
}

/**
 * Generates a deterministic friendly name based on a seed value using unique-names-generator
 *
 * Uses a simple hash function to ensure the same seed always produces
 * the same name. Perfect for generating consistent names for anonymous users.
 *
 * @param {string} seed - Seed value (e.g., user ID, session ID, IP address)
 * @returns {string} A deterministic friendly name in "Adjective Name" format
 *
 * @example
 * generateDeterministicName("user-123") // Always returns "Cheerful Morgan"
 * generateDeterministicName("session-abc") // Always returns "Swift River"
 */
export function generateDeterministicName(seed: string): string {
  // Simple hash function to convert string to number
  let hash = 0;
  for (let i = 0; i < seed.length; i++) {
    const char = seed.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32-bit integer
  }

  // Set a seed for the generator (not directly supported, so we'll use our hash)
  const adjIndex = Math.abs(hash) % adjectives.length;
  const animalIndex = Math.abs(hash >> 8) % animals.length;

  return `${adjectives[adjIndex]} ${animals[animalIndex]}`;
}

/**
 * Generate a unique visitor name using unique-names-generator with better variety
 * 
 * @param {string} seed - Seed value for deterministic generation
 * @returns {string} A friendly visitor name with proper capitalization
 */
export function generateUniqueVisitorName(seed: string): string {
  // Simple hash function to convert string to number
  let hash = 0;
  for (let i = 0; i < seed.length; i++) {
    const char = seed.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32-bit integer
  }

  // Use unique-names-generator with color + animal combination
  const adjIndex = Math.abs(hash) % colors.length;
  const animalIndex = Math.abs(hash >> 8) % animals.length;

  // Get the color and animal names
  const color = colors[adjIndex];
  const animal = animals[animalIndex];

  // Properly capitalize each word
  const capitalizedColor = color.charAt(0).toUpperCase() + color.slice(1);
  const capitalizedAnimal = animal.charAt(0).toUpperCase() + animal.slice(1);

  return `${capitalizedColor} ${capitalizedAnimal}`;
}

/**
 * Checks if a name appears to be generated by this module
 *
 * Useful for identifying anonymous users vs. users who provided their real names.
 *
 * @param {string} name - The name to check
 * @returns {boolean} True if the name matches the generated pattern
 *
 * @example
 * isGeneratedName("Friendly River") // true
 * isGeneratedName("John Smith") // false
 * isGeneratedName("River") // false (not two words)
 */
export function isGeneratedName(name: string): boolean {
  if (!name || typeof name !== "string") return false;

  const parts = name.trim().split(" ");
  if (parts.length !== 2) return false;

  const [adjective, namePart] = parts;
  
  // Check against both legacy and new name patterns
  const isLegacyName = legacyAdjectives.includes(adjective!) && legacyNames.includes(namePart!);
  const isNewName = (adjectives.includes(adjective!) || colors.includes(adjective!)) && animals.includes(namePart!);
  
  return isLegacyName || isNewName;
}

/**
 * Gets CSS gradient style for avatar based on name
 *
 * Generates a deterministic gradient background that can be used for
 * avatar placeholders. The same name always produces the same gradient.
 *
 * @param {string} name - The name to generate gradient for
 * @returns {React.CSSProperties} CSS properties object with gradient background
 *
 * @example
 * const style = getAvatarGradientStyle("Friendly River");
 * // Returns: { background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' }
 *
 * // Usage in React component
 * <div style={getAvatarGradientStyle(user.name)} />
 */
export function getAvatarGradientStyle(name: string): React.CSSProperties {
  if (!name) {
    return {
      background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
    };
  }

  // Generate deterministic color based on name
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    const char = name.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }

  const colorIndex = Math.abs(hash) % gradientColors.length;
  const colors = gradientColors[colorIndex] || gradientColors[0];
  const [color1, color2] = colors!;

  return {
    background: `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`,
  };
}

/**
 * Get primary color for a name (for consistent theming)
 */
export function getPrimaryColorForName(name: string): string {
  if (!name) return "#667eea";

  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    const char = name.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }

  const colorIndex = Math.abs(hash) % gradientColors.length;
  return gradientColors[colorIndex]?.[0] || "#64748b"; // Return the first color of the gradient
}

/**
 * Get initials from a name
 */
export function getInitials(name: string): string {
  if (!name || typeof name !== "string") return "?";

  const parts = name.trim().split(" ");
  if (parts.length === 1) {
    return parts[0]?.charAt(0).toUpperCase() || "?";
  }

  return parts
    .slice(0, 2)
    .map((part: any) => part.charAt(0).toUpperCase())
    .join("");
}

/**
 * Generate a wave-like gradient for avatars
 */
export function getWaveGradientStyle(name: string): React.CSSProperties {
  const baseStyle = getAvatarGradientStyle(name);

  return {
    ...baseStyle,
    backgroundSize: "200% 200%",
    animation: "wave 3s ease-in-out infinite",
  };
}

/**
 * Create an anonymous customer with generated name and details
 */
export function createAnonymousCustomer(seed?: string) {
  const actualSeed = seed || `anonymous-${Date.now()}`;
  const name = generateDeterministicName(actualSeed);
  const email = `${name.toLowerCase().replace(" ", ".")}@example.com`;

  return {
    name,
    email,
    avatar: "", // Will use generated gradient
    isGenerated: true,
  };
}

/**
 * Get gradient information for a name
 */
export function getGradientForName(name: string): { name: string; colors: string[] } {
  if (!name) {
    return {
      name: "Purple-Blue",
      colors: ["#667eea", "#764ba2"],
    };
  }

  // Generate deterministic gradient based on name
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    const char = name.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }

  const gradientNames = ["Purple-Blue", "Pink-Red", "Blue-Cyan", "Green-Teal", "Pink-Yellow"];
  const colorIndex = Math.abs(hash) % gradientColors.length;

  return {
    name: gradientNames[colorIndex] || gradientNames[0]!,
    colors: gradientColors[colorIndex] || gradientColors[0]!,
  };
}
