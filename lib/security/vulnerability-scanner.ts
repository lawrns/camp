/**
 * Vulnerability Scanner and Security Assessment
 * 
 * Features:
 * - Dependency vulnerability scanning
 * - Secret detection
 * - Code security analysis
 * - Runtime security monitoring
 * - Compliance checking
 * - Automated remediation suggestions
 */

import { execSync } from 'child_process';
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

// ============================================================================
// TYPES
// ============================================================================

interface VulnerabilityReport {
  id: string;
  timestamp: string;
  scanType: ScanType;
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  vulnerabilities: Vulnerability[];
  recommendations: Recommendation[];
  complianceStatus: ComplianceStatus;
}

interface Vulnerability {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  type: VulnerabilityType;
  title: string;
  description: string;
  affectedComponent: string;
  cve?: string;
  cvss?: number;
  fixAvailable: boolean;
  fixVersion?: string;
  references: string[];
  firstDetected: string;
  lastSeen: string;
}

interface Recommendation {
  id: string;
  priority: 'immediate' | 'high' | 'medium' | 'low';
  action: string;
  description: string;
  estimatedEffort: string;
  automatable: boolean;
}

interface ComplianceStatus {
  gdpr: boolean;
  ccpa: boolean;
  sox: boolean;
  pci: boolean;
  hipaa: boolean;
  issues: string[];
}

type ScanType = 
  | 'dependencies'
  | 'secrets'
  | 'code_analysis'
  | 'runtime'
  | 'compliance'
  | 'full';

type VulnerabilityType = 
  | 'dependency'
  | 'secret_exposure'
  | 'code_injection'
  | 'xss'
  | 'csrf'
  | 'authentication'
  | 'authorization'
  | 'data_exposure'
  | 'configuration'
  | 'compliance';

// ============================================================================
// VULNERABILITY SCANNER CLASS
// ============================================================================

export class VulnerabilityScanner {
  private projectRoot: string;
  private scanHistory: VulnerabilityReport[] = [];

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
  }

  // ============================================================================
  // MAIN SCANNING METHODS
  // ============================================================================

  public async runFullScan(): Promise<VulnerabilityReport> {
    const report: VulnerabilityReport = {
      id: this.generateReportId(),
      timestamp: new Date().toISOString(),
      scanType: 'full',
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
      vulnerabilities: [],
      recommendations: [],
      complianceStatus: {
        gdpr: true,
        ccpa: true,
        sox: true,
        pci: true,
        hipaa: true,
        issues: [],
      },
    };

    try {
      // Run all scan types
      const dependencyVulns = await this.scanDependencies();
      const secretVulns = await this.scanSecrets();
      const codeVulns = await this.scanCode();
      const runtimeVulns = await this.scanRuntime();
      const complianceIssues = await this.scanCompliance();

      // Combine results
      report.vulnerabilities = [
        ...dependencyVulns,
        ...secretVulns,
        ...codeVulns,
        ...runtimeVulns,
        ...complianceIssues,
      ];

      // Calculate summary
      report.summary = this.calculateSummary(report.vulnerabilities);

      // Generate recommendations
      report.recommendations = this.generateRecommendations(report.vulnerabilities);

      // Check compliance status
      report.complianceStatus = this.checkComplianceStatus(report.vulnerabilities);

      // Store report
      this.scanHistory.push(report);

      return report;

    } catch (error) {
      console.error('Full scan failed:', error);
      throw error;
    }
  }

  // ============================================================================
  // DEPENDENCY SCANNING
  // ============================================================================

  public async scanDependencies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Run npm audit
      const auditResult = this.runNpmAudit();
      vulnerabilities.push(...this.parseNpmAuditResults(auditResult));

      // Run yarn audit if yarn.lock exists
      if (this.fileExists('yarn.lock')) {
        const yarnAuditResult = this.runYarnAudit();
        vulnerabilities.push(...this.parseYarnAuditResults(yarnAuditResult));
      }

      // Check for outdated packages
      const outdatedPackages = this.checkOutdatedPackages();
      vulnerabilities.push(...this.parseOutdatedPackages(outdatedPackages));

    } catch (error) {
      console.error('Dependency scan failed:', error);
    }

    return vulnerabilities;
  }

  private runNpmAudit(): any {
    try {
      const result = execSync('npm audit --json', {
        cwd: this.projectRoot,
        encoding: 'utf8',
      });
      return JSON.parse(result);
    } catch (error: any) {
      // npm audit returns non-zero exit code when vulnerabilities found
      if (error.stdout) {
        return JSON.parse(error.stdout);
      }
      throw error;
    }
  }

  private parseNpmAuditResults(auditResult: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (auditResult.vulnerabilities) {
      Object.entries(auditResult.vulnerabilities).forEach(([packageName, vuln]: [string, any]) => {
        vuln.via.forEach((via: any) => {
          if (typeof via === 'object') {
            vulnerabilities.push({
              id: `npm-${via.source || packageName}-${Date.now()}`,
              severity: this.mapSeverity(via.severity),
              type: 'dependency',
              title: `${packageName}: ${via.title}`,
              description: via.url || 'No description available',
              affectedComponent: packageName,
              cve: via.cve?.[0],
              cvss: via.cvss?.score,
              fixAvailable: !!vuln.fixAvailable,
              fixVersion: vuln.fixAvailable?.version,
              references: via.cve || [],
              firstDetected: new Date().toISOString(),
              lastSeen: new Date().toISOString(),
            });
          }
        });
      });
    }

    return vulnerabilities;
  }

  // ============================================================================
  // SECRET SCANNING
  // ============================================================================

  public async scanSecrets(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Scan common files for secrets
      const filesToScan = [
        '.env',
        '.env.local',
        '.env.production',
        'config.js',
        'config.ts',
        'package.json',
      ];

      for (const file of filesToScan) {
        if (this.fileExists(file)) {
          const secrets = this.scanFileForSecrets(file);
          vulnerabilities.push(...secrets);
        }
      }

      // Scan source code for hardcoded secrets
      const codeSecrets = this.scanCodeForSecrets();
      vulnerabilities.push(...codeSecrets);

    } catch (error) {
      console.error('Secret scan failed:', error);
    }

    return vulnerabilities;
  }

  private scanFileForSecrets(filePath: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const content = readFileSync(join(this.projectRoot, filePath), 'utf8');
    
    const secretPatterns = [
      { name: 'AWS Access Key', pattern: /AKIA[0-9A-Z]{16}/ },
      { name: 'AWS Secret Key', pattern: /[0-9a-zA-Z/+]{40}/ },
      { name: 'GitHub Token', pattern: /ghp_[0-9a-zA-Z]{36}/ },
      { name: 'Slack Token', pattern: /xox[baprs]-[0-9a-zA-Z-]+/ },
      { name: 'Private Key', pattern: /-----BEGIN [A-Z ]+PRIVATE KEY-----/ },
      { name: 'Database URL', pattern: /postgres:\/\/[^:]+:[^@]+@/ },
      { name: 'API Key', pattern: /['"](sk|pk)_[a-zA-Z0-9]{20,}['"]/ },
    ];

    secretPatterns.forEach(({ name, pattern }) => {
      const matches = content.match(pattern);
      if (matches) {
        vulnerabilities.push({
          id: `secret-${filePath}-${name}-${Date.now()}`,
          severity: 'critical',
          type: 'secret_exposure',
          title: `${name} exposed in ${filePath}`,
          description: `Potential ${name} found in ${filePath}. This should be moved to environment variables.`,
          affectedComponent: filePath,
          fixAvailable: true,
          references: [],
          firstDetected: new Date().toISOString(),
          lastSeen: new Date().toISOString(),
        });
      }
    });

    return vulnerabilities;
  }

  private scanCodeForSecrets(): Vulnerability[] {
    // This would scan all source files for hardcoded secrets
    // For brevity, returning empty array
    return [];
  }

  // ============================================================================
  // CODE ANALYSIS
  // ============================================================================

  public async scanCode(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Check for common security anti-patterns
      const securityIssues = this.scanForSecurityAntiPatterns();
      vulnerabilities.push(...securityIssues);

      // Check TypeScript configuration
      const tsConfigIssues = this.scanTypeScriptConfig();
      vulnerabilities.push(...tsConfigIssues);

      // Check Next.js configuration
      const nextConfigIssues = this.scanNextJsConfig();
      vulnerabilities.push(...nextConfigIssues);

    } catch (error) {
      console.error('Code analysis failed:', error);
    }

    return vulnerabilities;
  }

  private scanForSecurityAntiPatterns(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Check for dangerous functions
    const dangerousPatterns = [
      { pattern: /eval\(/, issue: 'Use of eval() function', severity: 'high' as const },
      { pattern: /innerHTML\s*=/, issue: 'Direct innerHTML assignment', severity: 'medium' as const },
      { pattern: /document\.write\(/, issue: 'Use of document.write()', severity: 'medium' as const },
      { pattern: /dangerouslySetInnerHTML/, issue: 'Use of dangerouslySetInnerHTML', severity: 'medium' as const },
    ];

    // This would scan all source files
    // For brevity, returning empty array
    return vulnerabilities;
  }

  private scanTypeScriptConfig(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    try {
      if (this.fileExists('tsconfig.json')) {
        const tsConfig = JSON.parse(readFileSync(join(this.projectRoot, 'tsconfig.json'), 'utf8'));
        
        if (!tsConfig.compilerOptions?.strict) {
          vulnerabilities.push({
            id: `ts-config-strict-${Date.now()}`,
            severity: 'medium',
            type: 'configuration',
            title: 'TypeScript strict mode not enabled',
            description: 'Enabling strict mode helps catch potential runtime errors at compile time.',
            affectedComponent: 'tsconfig.json',
            fixAvailable: true,
            references: ['https://www.typescriptlang.org/tsconfig#strict'],
            firstDetected: new Date().toISOString(),
            lastSeen: new Date().toISOString(),
          });
        }
      }
    } catch (error) {
      console.error('TypeScript config scan failed:', error);
    }

    return vulnerabilities;
  }

  private scanNextJsConfig(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    try {
      if (this.fileExists('next.config.js') || this.fileExists('next.config.mjs')) {
        // Check for security headers
        // This would analyze the Next.js configuration
        // For brevity, returning empty array
      }
    } catch (error) {
      console.error('Next.js config scan failed:', error);
    }

    return vulnerabilities;
  }

  // ============================================================================
  // RUNTIME SCANNING
  // ============================================================================

  public async scanRuntime(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Check environment variables
      const envIssues = this.scanEnvironmentVariables();
      vulnerabilities.push(...envIssues);

      // Check file permissions
      const permissionIssues = this.scanFilePermissions();
      vulnerabilities.push(...permissionIssues);

    } catch (error) {
      console.error('Runtime scan failed:', error);
    }

    return vulnerabilities;
  }

  private scanEnvironmentVariables(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    const requiredEnvVars = [
      'NEXT_PUBLIC_SUPABASE_URL',
      'NEXT_PUBLIC_SUPABASE_ANON_KEY',
      'SUPABASE_SERVICE_ROLE_KEY',
    ];

    requiredEnvVars.forEach(envVar => {
      if (!process.env[envVar]) {
        vulnerabilities.push({
          id: `env-missing-${envVar}-${Date.now()}`,
          severity: 'high',
          type: 'configuration',
          title: `Missing environment variable: ${envVar}`,
          description: `Required environment variable ${envVar} is not set.`,
          affectedComponent: 'environment',
          fixAvailable: true,
          references: [],
          firstDetected: new Date().toISOString(),
          lastSeen: new Date().toISOString(),
        });
      }
    });

    return vulnerabilities;
  }

  private scanFilePermissions(): Vulnerability[] {
    // This would check file permissions for security issues
    // For brevity, returning empty array
    return [];
  }

  // ============================================================================
  // COMPLIANCE SCANNING
  // ============================================================================

  public async scanCompliance(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Check GDPR compliance
      const gdprIssues = this.scanGDPRCompliance();
      vulnerabilities.push(...gdprIssues);

      // Check security headers
      const headerIssues = this.scanSecurityHeaders();
      vulnerabilities.push(...headerIssues);

    } catch (error) {
      console.error('Compliance scan failed:', error);
    }

    return vulnerabilities;
  }

  private scanGDPRCompliance(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Check for privacy policy
    if (!this.fileExists('PRIVACY.md') && !this.fileExists('privacy-policy.md')) {
      vulnerabilities.push({
        id: `gdpr-privacy-policy-${Date.now()}`,
        severity: 'high',
        type: 'compliance',
        title: 'Missing privacy policy',
        description: 'GDPR requires a clear privacy policy to be available.',
        affectedComponent: 'documentation',
        fixAvailable: true,
        references: ['https://gdpr.eu/privacy-notice/'],
        firstDetected: new Date().toISOString(),
        lastSeen: new Date().toISOString(),
      });
    }

    return vulnerabilities;
  }

  private scanSecurityHeaders(): Vulnerability[] {
    // This would check for proper security headers in middleware/config
    // For brevity, returning empty array
    return [];
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  private calculateSummary(vulnerabilities: Vulnerability[]): VulnerabilityReport['summary'] {
    const summary = { total: 0, critical: 0, high: 0, medium: 0, low: 0 };

    vulnerabilities.forEach(vuln => {
      summary.total++;
      summary[vuln.severity]++;
    });

    return summary;
  }

  private generateRecommendations(vulnerabilities: Vulnerability[]): Recommendation[] {
    const recommendations: Recommendation[] = [];

    // Group by type and generate recommendations
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
    if (criticalVulns.length > 0) {
      recommendations.push({
        id: `rec-critical-${Date.now()}`,
        priority: 'immediate',
        action: 'Fix critical vulnerabilities',
        description: `Address ${criticalVulns.length} critical vulnerabilities immediately.`,
        estimatedEffort: '1-2 hours',
        automatable: false,
      });
    }

    return recommendations;
  }

  private checkComplianceStatus(vulnerabilities: Vulnerability[]): ComplianceStatus {
    const complianceIssues = vulnerabilities.filter(v => v.type === 'compliance');
    
    return {
      gdpr: !complianceIssues.some(v => v.title.includes('GDPR')),
      ccpa: !complianceIssues.some(v => v.title.includes('CCPA')),
      sox: !complianceIssues.some(v => v.title.includes('SOX')),
      pci: !complianceIssues.some(v => v.title.includes('PCI')),
      hipaa: !complianceIssues.some(v => v.title.includes('HIPAA')),
      issues: complianceIssues.map(v => v.title),
    };
  }

  private mapSeverity(severity: string): Vulnerability['severity'] {
    switch (severity?.toLowerCase()) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'moderate':
      case 'medium': return 'medium';
      case 'low':
      case 'info': return 'low';
      default: return 'medium';
    }
  }

  private fileExists(filePath: string): boolean {
    try {
      readFileSync(join(this.projectRoot, filePath));
      return true;
    } catch {
      return false;
    }
  }

  private generateReportId(): string {
    return `vuln_scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private runYarnAudit(): any {
    // Implementation for yarn audit
    return {};
  }

  private parseYarnAuditResults(auditResult: any): Vulnerability[] {
    // Implementation for parsing yarn audit results
    return [];
  }

  private checkOutdatedPackages(): any {
    // Implementation for checking outdated packages
    return {};
  }

  private parseOutdatedPackages(outdatedPackages: any): Vulnerability[] {
    // Implementation for parsing outdated packages
    return [];
  }

  // ============================================================================
  // REPORTING
  // ============================================================================

  public generateReport(report: VulnerabilityReport): string {
    let output = `# Vulnerability Scan Report\n\n`;
    output += `**Scan ID:** ${report.id}\n`;
    output += `**Timestamp:** ${report.timestamp}\n`;
    output += `**Scan Type:** ${report.scanType}\n\n`;

    output += `## Summary\n\n`;
    output += `- **Total:** ${report.summary.total}\n`;
    output += `- **Critical:** ${report.summary.critical}\n`;
    output += `- **High:** ${report.summary.high}\n`;
    output += `- **Medium:** ${report.summary.medium}\n`;
    output += `- **Low:** ${report.summary.low}\n\n`;

    if (report.vulnerabilities.length > 0) {
      output += `## Vulnerabilities\n\n`;
      report.vulnerabilities.forEach(vuln => {
        output += `### ${vuln.title}\n`;
        output += `- **Severity:** ${vuln.severity}\n`;
        output += `- **Type:** ${vuln.type}\n`;
        output += `- **Component:** ${vuln.affectedComponent}\n`;
        output += `- **Description:** ${vuln.description}\n`;
        if (vuln.fixAvailable) {
          output += `- **Fix Available:** Yes${vuln.fixVersion ? ` (${vuln.fixVersion})` : ''}\n`;
        }
        output += `\n`;
      });
    }

    if (report.recommendations.length > 0) {
      output += `## Recommendations\n\n`;
      report.recommendations.forEach(rec => {
        output += `### ${rec.action}\n`;
        output += `- **Priority:** ${rec.priority}\n`;
        output += `- **Description:** ${rec.description}\n`;
        output += `- **Estimated Effort:** ${rec.estimatedEffort}\n`;
        output += `- **Automatable:** ${rec.automatable ? 'Yes' : 'No'}\n\n`;
      });
    }

    return output;
  }

  public saveReport(report: VulnerabilityReport, filePath?: string): void {
    const reportContent = this.generateReport(report);
    const fileName = filePath || `vulnerability-report-${report.id}.md`;
    writeFileSync(join(this.projectRoot, fileName), reportContent);
  }
}

// ============================================================================
// SINGLETON INSTANCE
// ============================================================================

export const vulnerabilityScanner = new VulnerabilityScanner();

// ============================================================================
// CLI INTERFACE
// ============================================================================

export async function runVulnerabilityScan(scanType: ScanType = 'full'): Promise<VulnerabilityReport> {
  console.log(`Starting ${scanType} vulnerability scan...`);
  
  const scanner = new VulnerabilityScanner();
  const report = await scanner.runFullScan();
  
  console.log(`Scan completed. Found ${report.summary.total} vulnerabilities.`);
  console.log(`Critical: ${report.summary.critical}, High: ${report.summary.high}, Medium: ${report.summary.medium}, Low: ${report.summary.low}`);
  
  // Save report
  scanner.saveReport(report);
  
  return report;
}
